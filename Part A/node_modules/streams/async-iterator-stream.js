"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncIteratorStream = void 0;
const iterator_1 = require("./sources/iterator");
const as_async_iterable_1 = require("./util/as-async-iterable");
//
// AsyncIteratorStream Implementation
//
/**
 * An asynchronous stream that produces elements of type `T` on demand.
 *
 * This is an extension of the built-in `AsyncIterable<T>` protocol.
 *
 * The operations defined here in AsyncIteratorStream are a superset of the
 * operations described in the
 * [Async Iterator Helpers](https://github.com/tc39/proposal-async-iterator-helpers)
 * proposal.
 *
 * The behavior of all operations here that correspond to operations in the
 * `Async Iterator Helpers` proposal are defined (as best as possible) to match
 * exactly with the behavior of the corresponding `Async Iterator Helpers`
 * operations. This is intended to allow users of this library to seamlessly
 * switch between this library and the `Async Iterator Helpers` once those are
 * implemented and available.
 *
 * However, this library is NOT a polyfill for `Async Iterator Helpers`. To use
 * this library, an async iterable iterator or generator needs to be explicitly
 * wrapped in an AsyncIteratorStream like in this example:
 *
 * ```
 * import "streams/asyncGenerator";
 *
 * async function* generator() {
 *   yield* [1, 2, 3];
 * }
 *
 * generator()               // returns an AsyncGenerator
 *   .stream()               // convert to AsyncIteratorStream first!
 *   .forEach(console.log);  // use the AsyncIteratorStream APIs
 * ```
 */
class AsyncIteratorStream {
    iterator;
    /**
     * Creates an AsyncIteratorStream from an Iterator or Iterable.
     *
     * ```
     * AsyncIteratorStream.from([1, 2, 3]).map(x => x * 2).forEach(console.log);
     * ```
     */
    static from(it) {
        if (typeof it[Symbol.asyncIterator] === "function") {
            return new AsyncIteratorStream(it[Symbol.asyncIterator]());
        }
        if (typeof it[Symbol.iterator] === "function") {
            return new AsyncIteratorStream((0, iterator_1.toAsync)(it[Symbol.iterator]()));
        }
        return new AsyncIteratorStream(it);
    }
    // The AsyncIterator protocol
    next;
    return;
    throw;
    constructor(iterator) {
        this.iterator = iterator;
        this.next = () => this.iterator.next();
        if (this.iterator.return !== undefined) {
            this.return = () => this.iterator.return();
        }
        if (this.iterator.throw !== undefined) {
            this.throw = (e) => this.iterator.throw(e);
        }
    }
    stream() {
        return this;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    async [Symbol.asyncDispose]() {
        await this.return?.();
    }
    // #region Intermediate operations
    /**
     * Returns a new stream that skips elements of this stream not matched by the
     * `predicate`.
     *
     * See also [IteratorHelpers#filter](https://github.com/tc39/proposal-iterator-helpers#filterfiltererfn).
     *
     * @param predicate a function that decides whether to include each element
     * in the new stream (true) or to exclude the element (false)
     */
    filter(predicate) {
        async function* filterOperator(it) {
            for await (const v of it) {
                if (predicate(v)) {
                    yield v;
                }
            }
        }
        return new AsyncIteratorStream(filterOperator(this));
    }
    /**
     * Returns a new stream that transforms each element of this stream
     * using the provided function.
     *
     * See also [IteratorHelpers#map](https://github.com/tc39/proposal-iterator-helpers#mapmapperfn).
     *
     * @param transform a function to apply to each element of this stream
     */
    map(transform) {
        // Do not use a generator here, as it will await the result of the
        // transform before yielding each mapped value.
        // The Iterator Helpers proposal requires that we yield immediately
        // without awaiting the transform result to resolve.
        function mapOperator(itrbl) {
            const it = itrbl[Symbol.asyncIterator]();
            function mapResult(sourceResult) {
                return new Promise((resolve, reject) => {
                    Promise.resolve(sourceResult).then((result) => {
                        if (result.done) {
                            resolve({ done: true, value: undefined });
                        }
                        else {
                            // transform could return a Promise...
                            const transformed = transform(result.value);
                            Promise.resolve(transformed).then((value) => resolve({ value, done: false }), reject);
                        }
                    }, reject);
                });
            }
            const nextMapped = () => {
                const sourceResult = it.next();
                return mapResult(sourceResult);
            };
            const mappedIterator = { next: nextMapped };
            if (it.return) {
                mappedIterator.return = (value) => {
                    const sourceResult = it.return(value);
                    return mapResult(sourceResult);
                };
            }
            if (it.throw) {
                mappedIterator.throw = (e) => {
                    const sourceResult = it.throw(e);
                    return mapResult(sourceResult);
                };
            }
            return mappedIterator;
        }
        return new AsyncIteratorStream(mapOperator(this));
    }
    /**
     * Like `map` but the result from each call to `transform` is awaited
     * before producing the next transformed element.
     *
     * @param transform an async function to apply to each element of this stream
     */
    mapAwait(transform) {
        async function* mapAwaitOperator(it) {
            for await (const v of it) {
                yield transform(v);
            }
        }
        return new AsyncIteratorStream(mapAwaitOperator(this));
    }
    /**
     *
     * See also [IteratorHelpers#flatMap](https://github.com/tc39/proposal-iterator-helpers#flatmapmapperfn).
     *
     * @param transform
     */
    flatMap(transform) {
        async function* flatMapOperator(it) {
            for await (const nested of it) {
                yield* (0, as_async_iterable_1.asAsyncIterable)(transform(nested));
            }
        }
        return new AsyncIteratorStream(flatMapOperator(this));
    }
    batch(batchSize) {
        if (batchSize < 1) {
            throw new Error("batchSize should be positive");
        }
        async function* batchOperator(it) {
            let acc = [];
            for await (const v of it) {
                acc.push(v);
                if (acc.length === batchSize) {
                    yield acc;
                    acc = [];
                }
            }
            if (acc.length > 0) {
                yield acc;
            }
        }
        return new AsyncIteratorStream(batchOperator(this));
    }
    /**
     * Returns a new stream that produces up to the first `limit` number of
     * elements of this stream.
     *
     * See also [IteratorHelpers#take](https://github.com/tc39/proposal-iterator-helpers#takelimit).
     *
     * @param limit the maximum number of items to produce
     */
    take(limit) {
        async function* takeOperator(it) {
            let count = 0;
            if (count >= limit) {
                return;
            }
            for await (const v of it) {
                yield v;
                count += 1;
                if (count >= limit) {
                    return;
                }
            }
        }
        return new AsyncIteratorStream(takeOperator(this));
    }
    /**
     *
     * See also [IteratorHelpers#drop](https://github.com/tc39/proposal-iterator-helpers#droplimit).
     *
     * @param n
     */
    drop(n) {
        async function* dropOperator(it) {
            let count = 0;
            for await (const v of it) {
                if (count >= n) {
                    yield v;
                }
                count += 1;
            }
        }
        return new AsyncIteratorStream(dropOperator(this));
    }
    dropWhile(predicate) {
        async function* dropWhileOperator(it) {
            let dropping = true;
            for await (const v of it) {
                dropping = dropping && predicate(v);
                if (!dropping) {
                    yield v;
                }
            }
        }
        return new AsyncIteratorStream(dropWhileOperator(this));
    }
    takeWhile(predicate) {
        async function* takeWhileOperator(it) {
            for await (const v of it) {
                if (!predicate(v)) {
                    return;
                }
                yield v;
            }
        }
        return new AsyncIteratorStream(takeWhileOperator(this));
    }
    peek(observer) {
        async function* peekOperator(it) {
            for await (const v of it) {
                observer(v);
                yield v;
            }
        }
        return new AsyncIteratorStream(peekOperator(this));
    }
    //
    // Terminal operations
    //
    /**
     *
     * See also [IteratorHelpers#forEach](https://github.com/tc39/proposal-iterator-helpers#foreachfn).
     *
     * @param block
     */
    async forEach(block) {
        for await (const v of this) {
            await block(v);
        }
    }
    async collect(container, accumulator, finisher) {
        for await (const v of this) {
            accumulator(container, v);
        }
        return finisher ? finisher(container) : container;
    }
    /**
     *
     * See also [IteratorHelpers#every](https://github.com/tc39/proposal-iterator-helpers#everyfn).
     *
     * @param predicate
     */
    async every(predicate) {
        for await (const v of this) {
            if (!(await predicate(v))) {
                return false;
            }
        }
        return true;
    }
    async some(predicate) {
        for await (const v of this) {
            if (await predicate(v)) {
                return true;
            }
        }
        return false;
    }
    async none(predicate) {
        for await (const v of this) {
            if (await predicate(v)) {
                return false;
            }
        }
        return true;
    }
    async count() {
        let count = 0;
        for await (const _ of this) {
            count += 1;
        }
        return count;
    }
    /**
     * Returns the first element that matches the predicate.
     *
     * This is the same as the {@link first()} method except that the predicate is
     * required and a `TypeError` will be thrown if a predicate is not supplied.
     *
     * See also [IteratorHelpers#find](https://github.com/tc39/proposal-iterator-helpers#findfn).
     *
     * @param predicate
     */
    async find(predicate) {
        for await (const v of this) {
            if (await predicate(v)) {
                return v;
            }
        }
        return undefined;
    }
    async first(predicate = (_) => true) {
        for await (const v of this) {
            if (await predicate(v)) {
                return v;
            }
        }
        return undefined;
    }
    async last(predicate = (_) => true) {
        let result;
        for await (const v of this) {
            if (await predicate(v)) {
                result = v;
            }
        }
        return result;
    }
    async max(comparator) {
        let result;
        let firstItem = true;
        for await (const v of this) {
            if (firstItem) {
                result = v;
                firstItem = false;
            }
            else {
                result = comparator(result, v) > 0 ? result : v;
            }
        }
        return result;
    }
    async min(comparator) {
        let result;
        let firstItem = true;
        for await (const v of this) {
            if (firstItem) {
                result = v;
                firstItem = false;
            }
            else {
                result = comparator(result, v) < 0 ? result : v;
            }
        }
        return result;
    }
    /**
     *
     * See also [IteratorHelpers#reduce](https://github.com/tc39/proposal-iterator-helpers#reducereducer--initialvalue-).
     *
     * @param reducer
     * @param initial
     */
    async reduce(reducer, initial) {
        const hasInitial = arguments.length >= 2;
        let firstItem = !hasInitial;
        let result = initial;
        for await (const v of this) {
            if (firstItem) {
                result = v; // R is assumed to be T when there is no initial value
                firstItem = false;
            }
            else {
                result = reducer(result, v);
            }
        }
        if (firstItem) {
            throw new TypeError("reduce without initial value but stream is empty");
        }
        return result;
    }
    async fold(reducer, initial) {
        const hasInitial = arguments.length >= 2;
        let firstItem = !hasInitial;
        let result = initial;
        for await (const v of this) {
            if (firstItem) {
                result = v; // R is assumed to be T when there is no initial value
                firstItem = false;
            }
            else {
                result = reducer(result, v);
            }
        }
        return result;
    }
    /**
     * See also [IteratorHelpers#toArray](https://github.com/tc39/proposal-iterator-helpers#toarray).
     */
    async toArray() {
        const result = [];
        for await (const v of this) {
            result.push(v);
        }
        return result;
    }
}
exports.AsyncIteratorStream = AsyncIteratorStream;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN5bmMtaXRlcmF0b3Itc3RyZWFtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3JjL2FzeW5jLWl0ZXJhdG9yLXN0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxpREFBNkM7QUFDN0MsZ0VBQTJEO0FBRTNELEVBQUU7QUFDRixxQ0FBcUM7QUFDckMsRUFBRTtBQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWdDRztBQUNILE1BQWEsbUJBQW1CO0lBMkJEO0lBeEI3Qjs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQUMsSUFBSSxDQUNULEVBQXlFO1FBRXpFLElBQUksT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxLQUFLLFVBQVUsRUFBRSxDQUFDO1lBQ25ELE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM3RCxDQUFDO1FBQ0QsSUFBSSxPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssVUFBVSxFQUFFLENBQUM7WUFDOUMsT0FBTyxJQUFJLG1CQUFtQixDQUFDLElBQUEsa0JBQU8sRUFBQyxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pFLENBQUM7UUFDRCxPQUFPLElBQUksbUJBQW1CLENBQUMsRUFBMEMsQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFFRCw2QkFBNkI7SUFDcEIsSUFBSSxDQUE2QjtJQUNqQyxNQUFNLENBQThCO0lBQ3BDLEtBQUssQ0FBeUM7SUFFdkQsWUFBNkIsUUFBOEM7UUFBOUMsYUFBUSxHQUFSLFFBQVEsQ0FBc0M7UUFDekUsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBMEIsQ0FBQztRQUMvRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxL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